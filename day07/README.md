# Day07

## 학습목표

- 문자열 구조를 분석해서 다양한 비교 조건을 구현할 수 있다.
- 배열, 사전, 맵 등 언어와 프레임워크에서 제공하는 컬렉션 타입을 다양하게 고려해서 다룰 수 있다.
- 표준 입출력 문제를 해결할 수 있다.
    - [코드 제출 💻]에 표준 입출력 처리 예제 코드가 포함되어 있습니다. 스스로 입출력을 처리해서 문제 해결에 도전해 보세요.

## 기능 요구 사항

컴퓨터에 있는 디렉토리와 파일이 너무 많아져서 2번 이상 중복된 파일을 찾아보려고 합니다.

문자열로 이루어진 파일명을 담은 배열이 매개변수로 주어집니다.

### 디렉토리와 파일 조건

다음 조건에 맞는 파일들 중에 중복된 파일 이름의 원본 파일명을 찾아서, 중복 개수와 함께 Map 형태로 return하도록 match()함수를 작성하세요.

- 디렉토리 이름이나 파일 이름은 알파벳 소문자 a-z중에 하나로 이뤄집니다.
- 파일 이름에는 **`.aa`**부터 **`.zz`**까지 항상 두 자리 확장자(두 글자)가 붙습니다. (예 : `a.aa`, `b.ef`, **`c.zz`**)
- 디렉토리 하위에는 **`/a/b/`**, **`a/c/b/`**처럼 다른 디렉토리가 포함될 수 있습니다.
- 파일 이름 뒤에는 **`_v1`**, **`_v2`**, …, **`_v9`**까지 최대 9종류의 버전을 추가로 붙일 수 있습니다.
- 버전 정보는 선택사항이라 **`a.zz`** 파일과 **`a_v1.zz`**, **`a_v9.zz`** 파일은 같은 파일로 인식합니다.
- 원본 파일명은 버전 정보가 포함되지 않은 파일명입니다.

## 프로그래밍 요구사항

- 입력값에는 반드시 파일명이 존재합니다. 대신 버전 정보는 생략 가능합니다.
- 디렉토리 깊이는 0단계 이상, 10단계 이하입니다. 예를 들어 **`/a.zz`**는 0단계, **`/a/a.zz`**는 1단계의 디렉토리 깊이를 가집니다.
- 입력값 파일명은 0개 이상, 100개 이하입니다.

## 예상 결과 및 동작 예시

### 입출력 예시

### **예시 1)**

입력값[**`"/a/a_v2.xa", "/b/a.xa", "/c/t.zz", "/d/a/t.xa", "/e/z/t_v1.zz", "/k/k/k/a_v9.xa"`**]
 
==> return {**`"a.xa" : 3, "t.zz", 2`**}

예시에서 **`/a/a_v2.xa -> a.xa`**, **`/b/a.xa -> a.xa`**, **`/k/k/k/a_v9.xa -> a.xa`** => **`a.xa`** 총 3회

**`/c/t.zz -> t.zz`**, **`/e/z/t_v1.zz -> t.zz`** => **`t.zz`** 총 2회

### **예시 2)**

입력값 [**`"/t.zp", "/z/z_v2.zp", "/a.za", "/d/b.zb", "/d/a/t.zp"`**]

==> return {**`"t.zp" : 2`**}

예시에서 **`/t.zp -> t.zp`**, **`/d/a/t.zp -> t.zp`** => **`t.zp`** 총 2회

### **예시 3)**

입력값 [**`"/t.yg", "/b/b.zg", "/a.zg", "/e/a.zz", "/d/a/x_v2.zg"`**]

==> return {}

중복된 파일이 없어서 빈 값 반환

## 구현

디렉토리의 깊이와 무관하게 파일의 존재 유무를 기반으로 2번 이상 중복된 파일을 찾아야 한다.

### 1. 불필요한 문자열을 제거하는 것을 우선순위 제거하기

구현을 설계하는 당시 불필요한 문자열을 하나씩 제거하는 방식을 생각하고 있었습니다. JavaScript가 익숙치 않아 찾아보니 **`replace`** 를 통해 제거할 수 있었으며, 이를 통해 제거하는 시도를 하였습니다.

→ 문제점 : 코드의 가독성이 지나치게 떨어진다. v1~v9까지의 문자열 제거 및 따옴표, 대괄호 등을 지우다 보니 가독성이 너무나 떨어지는 것을 확인하고 이를 획기적으로 줄일 수 있는 방법을 찾았습니다. 

→ 해결 : **`split(’/’).pop()` 을 통해 /를 기준으로 나누어진 파일명의 문자열들 중 가장 마지막 요소를 빼내는 방식으로 파일명만 추출하였습니다.**

_v1~9에 대한 처리는 앞서 설명한 replace와 정규식을 이용하여 제거하였습니다.

```jsx
    // 마지막 파일명 추출 후 _v1~_v9 제거
    const files = inputList.map(path => {
        return path
            .split('/').pop()         // 마지막 파일명
            .replace(/_v[1-9]/i, ''); // _v1~_v9 제거 (대소문자 구분 X)
    });
```

### 2. 중복된 파일명의 개수 카운트하기

입력 받은 모든 파일들에 대해 반복을 진행하며, Map형태로 중복된 key(파일명)들을 제거하였습니다.

**`fileCount.get(file) || 0`** 을 통해 만약 처음 등장하는 파일명인 경우 undefined를 반환할 것이고 그렇지 않은 경우 현재 카운트 값을 가져온다. 이를 통해 중복된 파일명의 개수를 셌습니다.

```jsx
    const fileCount = new Map();
    for (let file of files) {
        fileCount.set(file, (fileCount.get(file) || 0) + 1);
    }
```

### 3. 중복 즉, 2개를 넘지 않은 파일명을 제외한 중복 파일 리스트와 개수 반환

```jsx
    const result = new Map();
    for (let [file, count] of fileCount.entries()) {
        if (count > 1) {
            result.set(file, count.toString());
        }
    }
```

### 후기

빨리 자바스크립트 문법을 마스터 해야겠다…