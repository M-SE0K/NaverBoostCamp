# Java Script의 Map

- **객체 - 키가 있는 컬렉션을 저장함**
- **배열 - 순서가 있는 컬렉션을 저장함**

## Map 자료형

- **키가 있는 데이터를 저장한다는 점에서 객체와 상당히 유사함. 다만, 맵은 키에 다양한 자료형을 허용한다는 점이 객체와의 차이점을 보인다. 객체의 경우 key값의 타입은 `String`으로 저장되기 때문**
- **Map은 삽입 순서를 기억하는 이터러블한 객체 → 그렇다면 순회시 값이 삽입된 순서대로 순회를 실시함.**
    
    **객체가 프로퍼티 순서를 기억하지 못하는 것과는 다름**
    
- **Map 메서드는 파라미터로 콜백함수를 받는데, 그 콜백 함수의 파라미터는 요소, index 그리고 현재 map 메서를 호출한 배열이다.**
- **검색, 삽입, 삭제 연산에 대해 O(1)의 시간복잡도를 가진다.**

```jsx
new Map() - 맵을 만든다.
map.set(key, value)- key를 이용해 value를 저장.
map.get(key) - key에 해당하는 값을 반환함. key가 존재하지 않으면 undefined를 반환.
map.has(key) - key가 존재하면 true, 존재하지 않으면 false를 반환
map.delete(key) - key에 해당하는 값을 삭제.
map.clear() - 맵 안의 모든 요소를 제거함
map.size() - 요소의 개수를 반환함.
```

## HashMap

- 데이터를 키-값 쌍으로 저장하고 효율적으로 검색, 삽입, 삭제를 할 수 있는 자료구조이다.
- **Map과 다르게 삽입 순서를 유지하여 키 순서에 대한 보장을 해주지 않는다.**
- **Map과 다르게 객체만 사용 가능한다. ex) Integer, String**

**📌 JavaScript**

```jsx
const map = new Map();
map.set('a', 1);
map.set({x: 2}, 3);
```

**→ 자바스크립트에서 Map은 HashMap과유사한 역할을 하지만, 내부 구현 방식이나 언어 특성에 따라 다른 점이 있다.**

- **Hasing**
    
    **HashMap의 핵심 원리로 해싱함수는 키를 받아서 정수값인 해시코드(Hashcode)를 반환하고, 반환된 해시코드는 Hash 배열의 각 요소인 버킷의 인덱스가 된다.**
    
    **→ 키를 주면 해싱 함수에 의해 해시코드로 변환되고, 해당 해시코든느 배열의 각 요소인 버킷의 인덱스 역할을 한다. 해당 버킷을 찾아가면 값을 삽입 및 조회할 수 있다.**
    
    → 이때 **해싱 충돌에 대해 고려해야 한다. 두 개 이상의 키가 동일한 해시 코드를 가질 때 충돌이 발생한다. 이는 성능 저하를 초래한다. 여기서 성능저하가 발생하는 원인은 다음과 같다.**
    
    **HashMap에서의 키는 유일한 값으로 동일한 키가 두 개가 존재하는 경우 즉, 덮어쓰기가 되지 않은 경우 사용자가 key값을 통해 반환 받는 value가 원하지 않는 값이 나올 수가 있다는 것이다. 이렇게 되면 사용자는 원하는 값을 찾기 위해 탐색 시간이 증가하게 되어 시간복잡도가 O(1)에서 최대 O(n)까지 증가할 수 있게 된다.**
    
- **해싱 충돌 해결방법**
    1. **체이닝(Chaining)**
        
        **각 버킷은 연결리스토로 구현되며 충돌이 발생하는 경우, 해당 버킷의 연결리스트에 새로운 키-값 쌍을 추가한다. → 배열 + 연결리스트**
        
        **하지만 이 방법 또한 최악의 경우 즉, 한 슬롯에 몰리는 경우 검색 시간이 O(n)까지 증가할 수 있다.**
        
    2. **개방 주소법 (Open Addressing)**
        
        **모든 키-값 쌍이 해시 테이블의 배열 내에 직접 저장된다. 충돌이 발생하면, 다른 빈 버킷의 위치를 찾아 삽입을 시도한다. “다른 위치를 찾는”과정은 방법은 여러 개이다. 선형, 제곱, 이중 해싱 등**
        
        - **선형 (Linear Probing) : 현재 해시 인덱스에서 +1씩하며 빈 슬롯을 찾는 방법이다.**
        - **제곱 (Quadratic Probing) : 탐색 거리를 제곱으로 증가시키며 빈 슬롯을 찾는 방법이다.**
        - **이중 해싱 (Double Hashing) : 두 개의 해시 함수를 사용하여 다음 인덱스 계산**